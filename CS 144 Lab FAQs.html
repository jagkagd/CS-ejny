<!DOCTYPE html>
<html style="" lang="en"><style id="stylish-1" class="stylish" type="text/css">/* ==UserStyle==
@name         Wikipedia Deep Dark Theme
@version      1.0.0
@description  Dark Wikipedia theme. Get a cleaner, easier-to-read wiki at night to focus on content while browsing a beautiful dark website.
@namespace    http://www.w3.org/1999/xhtml
@author       n0x
@homepageURL  https://github.com/n0x-styles/wikipedia-dark
@supportURL   https://github.com/n0x-styles/wikipedia-dark/issues
@updateURL    https://raw.githubusercontent.com/n0x-styles/wikipedia-dark/master/wikipedia-dark.user.css
@license      CC0
@preprocessor default
==/UserStyle== */

@namespace url(http://www.w3.org/1999/xhtml);</style><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="CS 144: Lab FAQ">
    <title>CS 144: Lab FAQs</title>
    <link href="CS%20144%20Lab%20FAQs_files/bootstrap.css" rel="stylesheet">
    <link href="CS%20144%20Lab%20FAQs_files/bootstrap-theme.css" rel="stylesheet">

    <link href="CS%20144%20Lab%20FAQs_files/css.css" rel="stylesheet">
    <link rel="shortcut icon" type="image/png" href="https://kangyupl.gitee.io/cs144.github.io/stanford.png">
  <script charset="utf-8" src="moz-extension://9deab18a-fffb-4d2f-bf5c-052423f18b77/js/btype.js"></script><script type="text/javascript" charset="utf-8" src="CS%20144%20Lab%20FAQs_files/gwdang-notifier-ff.js"></script><script src="CS%20144%20Lab%20FAQs_files/prompt.js"></script></head>

  <body style="">
    <div class="container" role="main">
      <div class="page-header">
        <h3>Lab FAQs</h3>
      </div>

      <h4>General</h4>
      <ol>
        <li><b>How will code style be graded?</b>
        <p>Here are some guidelines:
</p><ul><li>Complex pieces of code should be documented in comments so 
that they become easier for the reader to understand—but don't overdo it
 with comments for trivial things.
</li><li>Common, general-purpose functionality should be decomposed into
 helper functions to avoid repeated code—don't overdo this either, e.g. 
by making it difficult to understand the flow of execution.
</li><li>Code should use consistent naming conventions and not contain commented-out code or vestiges of debugging.

</li><li>Please check the return values of all functions in which an 
error could occur, and handle these errors gracefully. Throwing an 
exception is one graceful way
to handle an unrecoverable error.

</li><li>Avoid memory errors and leaks, egregious performance issues 
(e.g. allocating large amounts of memory for no reason) or unnecessarily
 complex approaches (e.g. a complicated data structure that is only 
marginally more efficient than something much simpler, or something 
available in the C++ standard library).

</li><li>You can check your code for memory leaks, invalid accesses, and undefined behavior by compiling with <code style="">cmake .. -DCMAKE_BUILD_TYPE=RelASan</code> and then <code style="">make clean</code>, <code style="">make</code>, then <code style="">make check</code> or running any of the individual apps.

</li><li>Before submitting each assignment, please run <code style="">make format</code> (to standardize the formatting), and make sure to remove any dummy code or comments that were included with the starter code.
</li></ul>

Your style grade may also include components of functionality not covered by the tests.
<p>
        </p></li><li><b>How much of my grade will come from style and to the quality of my writeup?</b></li>
        <p>Grading breakdown for labs: 15% style, 10% writeup, 75% functionality.</p>

        <li><b>How do I run an individual test?</b></li>
        <p><code style="">ctest -R '^test_name$'</code></p>

        <li><b>Can I add include lines in the header files?</b></li>
        <p>Sure.</p>

        <li><b>Why does 'make check' fail even though it's in the Sponge README?</b></li>
        <p>Short Answer: This is a typo in our documentation. You should run <code style="">make check_lab0</code>, not <code style="">make check</code>.
        <br>
        Long Answer: The make target, <code style="">check</code>, runs the entire sponge test suite. The full test suite requires a shell script, <code style="">tun.sh</code>, which you won't get until a later lab. The make target <code style="">check_lab0</code>
 will just test lab0. You should be able to run it with the lab0 starter
 code (although it will return an error until you've completed the 
lab!).</p>

        <li><b>What's the procedure if I want to use some of my late days?</b></li>
        <p>To use a late day, please email the staff list 
(cs144-aut1920-staff@lists.stanford.edu) by the lab deadline, letting us
 know if you are using late days. With weekly labs, the CAs want to be 
able to get feedback to you quickly. As such, we will start grading as 
soon as the deadline passes, and want to avoid redundantly grading 
submissions that weren't intended to be final.</p>

        <li><b>How do I use <code style="">git</code>?</b></li>

	<p>Here are some links to <a href="https://try.github.io/">resources to learn Git</a>.

        </p><p><b>Brief summary:</b> Git commits store a snapshot of the
 current state of your code. For instance, say you break a feature that 
you know used to work, but aren't sure which code caused it to break. If
 you made a commit after getting that feature working, you can checkout 
that commit to see what things looked like in the good old days when it 
worked. So, make a commit every time you get something working! To make a
 commit:<br>
        First, git add the files you've changed - you must add before every commit. e.g. <code style="">git add ../libsponge/byte_stream.*</code><br>
        Then, commit with a message describing the state of the code. e.g. <code style="">git commit -m "All tests pass except many_writes times out."</code><br>
        You can see which files you modified by running <code style="">git status</code>. To really understand the state of a Git repository, the command-line <code style="">tig</code> tool, or the graphical <code style="">gitk</code> tool, can be very helpful.<br>
        A handy shortcut to commit all modified files is <code style="">git commit -am "[message]"</code>.<br>
        Don't <code style="">git push</code> - when you're ready to submit, you'll use git bundle instead to package your commits.
        </p><p><b>Sanity check:</b> If you want to verify that you have submitted exactly the files you intended to, you may find the following useful.<br>
        First, once you've committed, run <code style="">git status</code>. You should see a message saying <code style="">nothing to commit, working tree clean</code>. If you have uncommitted changes, you'll see this instead: <code style="">Changes not staged for commit:</code>.
        <br>
        Second, after you've copied your git bundle to rice, and logged into rice:
        </p><ol>
          <li>Run <code style="">$ git clone [bundle name] [unbundled name]</code>.</li>
          <li><code style="">cd</code> into the unbundled directory.</li>
          <li>Run <code style="">$ git log</code> and verify that you see the commits you expect to.
          </li><li>Copy the commit hash of the starter code commit.</li>
          <li>Run <code style="">$ git diff [hash]</code> to make sure they see all changes you want to submit.</li>
        </ol><p></p>

        <li><b>How do I debug?</b></li>
        <p><code style="">gdb</code> is a great tool for debugging the labs! Check out the <a href="https://web.stanford.edu/class/archive/cs/cs107/cs107.1202/resources/gdb">CS107 guide</a> if you need a refresher.<br>

        To use <code style="">gdb</code> to debug a test:
        </p><ol>
          <li>Install <code style="">gdb</code> (on the VM, <code style="">sudo apt-get install gdb</code>).</li>
          <li>Start <code style="">gdb</code> on the executable corresponding to the test you want to debug (from the <code style="">build</code> directory, <code style="">ls tests</code> to see the executables). e.g. from the build directory: <code style="">gdb tests/byte_stream_one_write</code>.</li>
          <li>The output of the test failure will show you the part of 
the test that failed. To set a breakpoint at that part of the test, 
break on the line in the test file where the test harness for that part 
is created. The test files are in <code style="">sponge/tests</code> (not <code style="">sponge/build/tests</code>). e.g. if you're failing the <code style="">write-pop2-end</code> test in <code style="">byte_stream_one_write</code>, <code style="">break 83</code> (i.e. where the <code style="">write-pop2-end</code> test harness is created).</li>
          <li>You can set breakpoints on your functions using the function names, as usual.</li>
        </ol>

        Other notes:
        <ul>
          <li>We don't recommend modifying any files in the <code style="">libsponge/util</code> directory, since messing up the sponge library will make debugging difficult.</li>
          <li>If a test is timing out, but you want to check if it 
passes without the timeout, run the test executable individually, which 
won't enforce the timeout. e.g. from the build directory: <code style="">./tests/byte_stream_one_write</code>.</li>
          <li><code style="">gdb</code> may help debug timeouts. While running the test in <code style="">gdb</code>,
 if it appears to hang (meaning it may be executing a slow portion of 
code), ctrl-C and backtrace to pause and see which code was executing.</li>
        </ul><p></p>
      </ol>

      <h4>Lab 0</h4>
      <ol>
        <li><b>What should the behaviour of my program be if the caller tries to peek or pop with a <code style="">len</code> greater than what is available?</b></li>
        We don't have any preference on the behavior if the caller tries
 to peek or pop more than is available in the stream, as long as you 
behave reasonably and don't crash in that situation. If you want to 
peek/pop the maximum available, that is fine with us. If you want to 
throw an exception (either for an overlength peek or an overlength pop),
 that is also fine with us.
      </ol>

      <h4>Lab 1</h4>
      <ol>
        <li><b>Which bytes should be accepted in a <code style="">push_substring</code> call?</b></li>
        Those whose index is within <code style="">capacity</code> indices of the first unread byte in the re-assembled stream.
        Pictorally:
        <img src="CS%20144%20Lab%20FAQs_files/reassembler.png">
        <li><b>Is it okay for our re-assembly data structure to store overlapping substrings?</b></li>
        It's possible to implement an interface-correct reassembler which stores overlapping substrings.
        However, allowing the re-assembler to do this undermines the notion of <code style="">capacity</code> as a memory limit, so we'll consider the storage of overlapping substrings to be a style violation when grading.
      </ol>

      <h4>Lab 2</h4>
      <ol>
        <li><b>Can we use <code style="">static_cast</code> in functions for <code style="">WrappingInt32</code>?</b></li>
        Yes, these kinds of functions (those that explicitly convert between
        numeric types) present exactly the kind of situation in which
        <code style="">static_cast</code> is appropriate. Note also that
        you don't
	<em>need</em> to use <code style="">static_cast</code> if you don't
	want to—you can
	explicitly construct a WrappingInt32 with syntax
	like <code style="">WrappingInt32{x}</code>.<p>

	</p><li><b>Should <code style="">TCPReceiver::segment_received()</code> return
	  true if <em>any</em> part of the segment is inside the window,
	  even if both the beginning and end of the segment are outside
	  the window?</b></li>

	Good question—please
	see <a href="https://piazza.com/class/k0u7fdam6082kb?cid=136">our
	Piazza note</a> where we clarify this. The short answer is
	that we've deleted a test in the lab2 starter code in order to
	make both answers to this question (yes and no) acceptable.
      </ol>

      <h4>Lab 4</h4>
      <ol>
	<li><b>In <code style="">TCPConnection::segment_received</code>, what
	    are the three conditions in which the TCPConnection needs
	    to make <b>sure</b> that the segment receives at least one
	    ACK segment in reply, and may need to force the TCPSender
	    to spit out an empty segment to make this happen?</b><br>

	  <ol>
	    <li>If the incoming segment occupies any sequence numbers
	      (<code style="">length_in_sequence_space() &gt; 0</code>)

	    </li><li>If the <code style="">TCPReceiver</code> thinks the segment
	      is unacceptable (<code style="">TCPReceiver::segment_received()</code> returns <code style="">false</code>)

	    </li><li>If the <code style="">TCPSender</code> thinks the ackno is invalid
	      (<code style="">TCPSender::ack_received()</code> returns <code style="">false</code>)
	  </li></ol>
	  <p>

	</p></li><li><b>Okay but hang on, what happens if
	    the TCPConnection wants to send an ACK
	    segment but the TCPReceiver's ackno is
	    missing (e.g. because it hasn't gotten an incoming SYN
	    yet)?</b><br>

	  If the ackno is missing, then you can't send an ACK segment.
	  Don't send one in this case.<p>

	    </p></li><li><b>When is the connection fully over (i.e., when should
		<code style="">active()</code> start returning false?</b><p>

		There are two ways a connection can fully end:

		</p><ul>
		  <li><i>[Unclean shutdown]</i> Any segment with the RST flag is sent or received, <b>or</b>

</li><li> <i>[Clean shutdown]</i> The sender is totally done (meaning, the sender's input stream is at EOF with no bytes in flight) <b>AND</b> the receiver is totally done (meaning, the receiver's output stream has ended) <b>AND either</b>

  <ul>
<li> <code style="">_linger_after_streams_finish</code> is false (no need to linger), or
</li><li><code style="">time_since_last_segment_received() &gt;= 10 * _cfg.rt_timeout</code> (we've lingered long enough)
</li></ul>
		</li></ul><p>

		</p></li><li><b>I think I may be having some trouble with my
logic about when a connection is fully over (i.e., when to stop
returning <code style="">true</code> from <code style="">active()</code>).  Some of my
tests are timing out. How can I debug this?</b><p>

Check out <a href="https://piazza.com/class/k0u7fdam6082kb?cid=277">this Piazza
thread</a> for a debugging approach that may help. It may be easier to
run the client and server manually (as described there) if you want to figure
out where things are going awry.</p><p>

	</p></li><li><b>The test suite keeps talking about the state of the TCPReceiver and TCPSender—what are these states?</b><br>

	  The test suite (and
	  the <a href="https://github.com/CS144/sponge/blob/lab4-startercode/libsponge/tcp_helpers/tcp_state.hh">tcp_state.hh</a>
	  and <a href="https://github.com/CS144/sponge/blob/lab4-startercode/libsponge/tcp_helpers/tcp_state.cc">tcp_state.cc</a>
	  files) uses the public interface of your TCPSender and
	  TCPReceiver to put them in broad categories or states. The
	  tests make sure that your TCPSender/TCPReceiver are in the
	  right state at the right time, given the actions taken.<p>

</p><hr>

Here is a diagram of the expected evolution (and definition of each
state) for the TCPReceiver. The receiver starts with no ISN (and
therefore no ackno) (<b>LISTEN</b>). Then it moves to a
state <b>SYN_SENT</b> where it has received a SYN segment (so there is
an ackno) but hasn't assembled a FIN segment (so the stream hasn't
ended). This is where most of the connection happens. Eventually the
receiver assembles a FIN segment and ends the stream
(<b>FIN_RECV</b>).
<p></p><p>

<img src="CS%20144%20Lab%20FAQs_files/receiver-evolution.svg">

</p><p>

</p><hr>

And here is a diagram of the expected evolution (and definition of
each state) for the TCPSender. The sender starts with nothing sent
(<b>CLOSED</b>), then moves to a state <b>SYN_SENT</b> where it has
sent something but nothing has been acknowledged. At some point, some
bytes are acknowledged (<b>SYN_ACKED</b>). This is where most of the
connection happens. Eventually, the stream ends and the sender sends a
FIN segment (<b>FIN_SENT</b>), and some time after that, the stream is
over and everything has been acknowledged (<b>FIN_ACKED</b>).

<p>

</p><p>

<img src="CS%20144%20Lab%20FAQs_files/sender-evolution.svg">

      </p></li></ol>
    </div>
  

</body></html>